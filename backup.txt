from flask import Flask, jsonify, request, render_template
import cv2
import numpy as np
import os
import face_recognition  # For face comparison
from datetime import datetime
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
from models import db, FDUser, FDLoginHistory
import pyodbc
from urllib.parse import quote_plus
import json

app = Flask(__name__)

def load_config():
    """Load configuration from config.json."""
    try:
        with open('config.json', 'r') as config_file:
            return json.load(config_file)
    except Exception as e:
        print("Error loading config.json:", e)
        return None

def initialize_database(app):
    """Initialize the database connection and configure SQLAlchemy."""
    try:
        config = load_config()
        if not config:
            raise Exception("Failed to load configuration")

        # Retrieve database parameters
        server = config['params']['server']
        database_name = config['params']['database_name']
        username = config['params']['username']
        password = config['params']['password']

        # Create the connection string
        conn_string = (
            f"DRIVER={{ODBC Driver 18 for SQL Server}};"
            f"SERVER={server};"
            f"DATABASE={database_name};"
            f"UID={username};"
            f"PWD={password};"
            f"Encrypt=yes;TrustServerCertificate=yes"
        )

        # Test the connection
        conn = pyodbc.connect(conn_string)
        conn.close()
        print("Database connection successful!")

        # Construct SQLAlchemy database URI
        db_uri = f"mssql+pyodbc:///?odbc_connect={quote_plus(conn_string)}"

        # Configure Flask app with SQLAlchemy
        app.config['SQLALCHEMY_DATABASE_URI'] = db_uri
        app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

        # Initialize SQLAlchemy and Flask-Migrate
        db.init_app(app)
        migrate = Migrate(app, db)

    except pyodbc.Error as e:
        print("Error connecting to the database:", e)
    except Exception as e:
        print("An unexpected error occurred:", e)

# Initialize the database
initialize_database(app)

# Pre-trained Haar Cascade for face detection
face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')

# Paths for storing data
image_folder = os.path.join(app.static_folder, 'images')
database_file = os.path.join(image_folder, 'face_encodings.npy')

# Ensure necessary folders exist
if not os.path.exists(image_folder):
    os.makedirs(image_folder)

# Load or initialize face database
if os.path.exists(database_file):
    face_encodings = np.load(database_file, allow_pickle=True).item()
else:
    face_encodings = {}  # Dictionary to store name:encoding

@app.route('/')
def index():
    """Render the main index page with navigation."""
    return render_template('index.html')

@app.route('/register', methods=['GET', 'POST'])
def register():
    """Render the registration page and handle user registration."""
    if request.method == 'GET':
        return render_template('register.html')
    
    try:
        name = request.form.get('name')  # Get the name from the form
        if not name:
            return jsonify({"error": "Name is required"}), 400

        # Capture the face
        cap = cv2.VideoCapture(0)
        ret, frame = cap.read()
        cap.release()

        if not ret:
            return jsonify({"error": "Failed to capture image"}), 500

        # Save image for reference
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        image_path = os.path.join(image_folder, f"{name}_{timestamp}.jpg")
        cv2.imwrite(image_path, frame)

        # Encode the face
        rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        face_locations = face_recognition.face_locations(rgb_frame)
        face_encodings_list = face_recognition.face_encodings(rgb_frame, face_locations)

        if len(face_encodings_list) != 1:
            return jsonify({"error": "Please ensure only one face is visible during registration"}), 400

        # Save encoding to the database
        face_encodings[name] = face_encodings_list[0]
        np.save(database_file, face_encodings)

        return jsonify({"message": f"User {name} registered successfully", "image_path": image_path})

    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/login', methods=['GET', 'POST'])
def login():
    """Render the login page and handle user authentication."""
    if request.method == 'GET':
        return render_template('login.html')

    try:
        # Capture the face
        cap = cv2.VideoCapture(0)
        ret, frame = cap.read()
        cap.release()

        if not ret:
            return jsonify({"error": "Failed to capture image"}), 500

        # Encode the face
        rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        face_locations = face_recognition.face_locations(rgb_frame)
        face_encodings_list = face_recognition.face_encodings(rgb_frame, face_locations)

        if len(face_encodings_list) != 1:
            return jsonify({"error": "Please ensure only one face is visible during login"}), 400

        # Compare with the database
        login_encoding = face_encodings_list[0]
        for name, registered_encoding in face_encodings.items():
            match = face_recognition.compare_faces([registered_encoding], login_encoding)
            if match[0]:
                return jsonify({"message": f"Login successful, welcome {name}!"})

        return jsonify({"error": "Face not recognized. Please register first"}), 401

    except Exception as e:
        return jsonify({"error": str(e)}), 500

if __name__ == '__main__':
    app.run(debug=True)
